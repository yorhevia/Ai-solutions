<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mi Calendario - Cliente</title>
    <link href='https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.css' rel='stylesheet' />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="/stylesheets/client_navbar.css"> 
    <link rel="stylesheet" href="/stylesheets/calendario_cliente.css"> 
</head>
<body>
    <%- include('../partials/client_navbar') %>

    <div class="calendario-page-container">
        <h1>Mi Calendario</h1>
        <p class="greeting" style="color: #666; font-size: 1.1em; margin-bottom: 25px; text-align: center; font-style: Arial;">Aquí puedes organizar y gestionar tus propios eventos personales.</p>

        <div class="calendario-content">
            <div id="calendar"></div>

            <div class="sidebar">
                <h2>Mis Próximos Eventos</h2>
                <ul id="event-list" class="event-list">
                    <li>Cargando eventos...</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Modal para Agregar/Editar/Eliminar Eventos -->
    <div id="eventModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2 id="modalTitle">Crear Nuevo Evento</h2>
            <form id="eventForm">
                <input type="hidden" id="eventId">
                <div class="form-group">
                    <label for="eventName">Título del Evento:</label>
                    <input type="text" id="eventName" required placeholder="Ej: Entrevista de trabajo, Cita médica">
                </div>
                <!-- Los campos de Fecha de Fin y Descripción han sido eliminados del HTML según la solicitud anterior -->
                <button type="submit" id="saveEventBtn">Guardar Evento</button>
                <button type="button" id="deleteEventBtn" class="delete-btn" style="display: none;">Eliminar Evento</button>
            </form>
        </div>
    </div>

    <%- include('../partials/footer') %>

    <!-- Incluye FullCalendar JS y su localización en español -->
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/main.min.js'></script>
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@5.11.3/locales/es.js'></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM Content Loaded. Starting FullCalendar setup for CLIENT (Own Calendar)...');

            var calendarEl = document.getElementById('calendar');
            var calendar;
            
            if (!calendarEl) {
                console.error('ERROR: No se encontró el elemento #calendar en el DOM. El calendario no se puede renderizar.');
                return;
            } else {
                console.log('Elemento #calendar encontrado en el DOM.');
            }

            // Referencias a elementos del DOM para el modal y la barra lateral
            const eventModal = document.getElementById('eventModal');
            const modalTitle = document.getElementById('modalTitle');
            const eventIdInput = document.getElementById('eventId');
            const eventNameInput = document.getElementById('eventName');
            const saveEventBtn = document.getElementById('saveEventBtn');
            const deleteEventBtn = document.getElementById('deleteEventBtn');
            const eventForm = document.getElementById('eventForm');
            const eventList = document.getElementById('event-list');

            // Variables para almacenar la fecha y el estado allDay de la selección/evento
            let currentSelectedDate = ''; // 'YYYY-MM-DD' para allDay, ISO string para timed
            let currentSelectedIsAllDay = false; 

            // --- Funciones para el Modal ---
            function openEventModal(eventId = null, title = '') {
                console.log('Abriendo modal para evento (Cliente - Propio):', eventId, 'Título:', title, 'Fecha seleccionada (para nuevo):', currentSelectedDate, 'Es día completo:', currentSelectedIsAllDay);
                eventNameInput.value = title;
                eventIdInput.value = eventId;

                if (eventId) {
                    modalTitle.innerText = 'Editar Evento';
                    saveEventBtn.innerText = 'Guardar Cambios';
                    deleteEventBtn.style.display = 'inline-block';
                } else {
                    modalTitle.innerText = 'Crear Nuevo Evento';
                    saveEventBtn.innerText = 'Crear Evento';
                    deleteEventBtn.style.display = 'none';
                }
                eventModal.classList.add('show-modal');
            }

            function closeEventModal() {
                console.log('Cerrando modal.');
                eventModal.classList.remove('show-modal');
                eventForm.reset();
                currentSelectedDate = ''; 
                currentSelectedIsAllDay = false; 
            }

            document.querySelector('.modal .close').addEventListener('click', closeEventModal);
            window.onclick = function(event) {
                if (event.target === eventModal) {
                    closeEventModal();
                }
            }

            // --- Inicialización de FullCalendar ---
            console.log('Inicializando FullCalendar para cliente (propio)...');
            calendar = new FullCalendar.Calendar(calendarEl, {
                initialView: 'dayGridMonth',
                locale: 'es', 
                timeZone: 'local', // <<-- CLAVE: FullCalendar trabaja en la zona horaria local del usuario
                headerToolbar: {
                    left: 'prev,next today',
                    center: 'title',
                    right: 'dayGridMonth,timeGridWeek,timeGridDay'
                },
                selectable: true,
                selectMirror: true,
                editable: true, 
                events: function(fetchInfo, successCallback, failureCallback) {
                    console.log('FullCalendar (Cliente - Propio): Fetching events from API...');
                    fetch('/cliente/api/eventos') // <--- RUTA DE API PARA LOS PROPIOS EVENTOS DEL CLIENTE (clienteEventos)
                        .then(response => {
                            if (!response.ok) {
                                return response.json().then(err => {
                                    throw new Error(`HTTP error! status: ${response.status} - ${err.message || response.statusText}`);
                                }).catch(() => {
                                    throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                                });
                            }
                            return response.json();
                        })
                        .then(data => {
                            console.log('Eventos recibidos de la API (para FullCalendar Cliente - Propio):', data);
                            const formattedEvents = data.map(event => {
                                const isAllDay = event.allDay === 1; // SQLite guarda 0/1 para booleanos

                                return {
                                    id: event.id,
                                    title: event.title,
                                    // FullCalendar maneja automáticamente los strings YYYY-MM-DD para allDay
                                    // y los ISO strings para eventos con hora.
                                    start: event.start, 
                                    end: event.end,     
                                    allDay: isAllDay, 
                                    extendedProps: { 
                                        description: event.description 
                                    }
                                };
                            });

                            if (Array.isArray(formattedEvents)) {
                                successCallback(formattedEvents);
                                renderEventSidebar(formattedEvents); // Pasamos los datos formateados para el sidebar
                            } else {
                                console.error('La API no devolvió un array de eventos o la respuesta es inesperada:', formattedEvents);
                                failureCallback();
                            }
                        })
                        .catch(error => {
                            console.error('Error al cargar eventos del calendario (API Cliente - Propio):', error);
                            alert('Error al cargar eventos: ' + error.message);
                            failureCallback();
                        });
                },
                // Cuando se hace clic en una fecha/hora del calendario (para crear)
                dateClick: function(info) {
                    console.log('Date clicked (Client - Propio):', info.dateStr, 'All day:', info.allDay, 'Date object:', info.date);
                    // Si es un evento de día completo, usamos la cadena 'YYYY-MM-DD'.
                    // Si tiene hora, usamos el ISO string completo (UTC).
                    currentSelectedDate = info.allDay ? info.dateStr : info.date.toISOString(); 
                    currentSelectedIsAllDay = info.allDay; 
                    openEventModal(null, ''); 
                },
                // Cuando se hace clic en un evento existente en el calendario (para editar)
                eventClick: function(info) {
                    console.log('Event clicked (Client - Propio):', info.event.id, info.event.title, 'Start:', info.event.startStr, 'All day:', info.event.allDay);
                    // Si es un evento de día completo, usamos la cadena 'YYYY-MM-DD'.
                    // Si tiene hora, usamos el ISO string completo (UTC).
                    currentSelectedDate = info.event.allDay ? info.event.startStr : info.event.start.toISOString(); 
                    currentSelectedIsAllDay = info.event.allDay; 
                    openEventModal(info.event.id, info.event.title); 
                },
                // Cuando se arrastra y suelta un evento para cambiar su fecha
                eventDrop: function(info) {
                    console.log('Event dropped (Client - Propio):', info.event.id, 'New start date object:', info.event.start, 'New start date string:', info.event.startStr, 'All day:', info.event.allDay);
                    const eventId = info.event.id;
                    // Asegúrate de enviar el formato correcto según si es allDay o no
                    const newStart = info.event.allDay ? info.event.startStr : info.event.start.toISOString(); 
                    const newTitle = info.event.title; 
                    // Si hay fecha de fin y es allDay, usa endStr. Si no es allDay, usa ISO string.
                    const newEnd = info.event.end ? (info.event.allDay ? info.event.endStr : info.event.end.toISOString()) : null; 
                    const newDescription = info.event.extendedProps.description || null;
                    const newAllDay = info.event.allDay; 

                    fetch(`/cliente/api/eventos/${eventId}`, { 
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            title: newTitle, 
                            start: newStart, 
                            end: newEnd,
                            description: newDescription,
                            allDay: newAllDay // <<-- Enviar el estado allDay al backend
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('Evento movido exitosamente (Cliente - Propio).');
                            calendar.refetchEvents(); 
                            fetchAndRenderEventSidebar(); 
                        } else {
                            alert('Error al mover evento (Cliente - Propio): ' + data.message);
                            info.revert(); 
                        }
                    })
                    .catch(error => {
                        console.error('Error de red al mover evento (Client - Propio):', error);
                        alert('Error de red al mover evento.');
                        info.revert();
                    });
                }
            });

            console.log('FullCalendar object created. Attempting to render...');
            calendar.render();
            console.log('FullCalendar render() called.');

            // --- Manejo del Formulario (Crear/Editar) ---
            eventForm.addEventListener('submit', function(e) {
                e.preventDefault();
                const eventId = eventIdInput.value;
                const title = eventNameInput.value;
                
                // currentSelectedDate ya debe estar en el formato correcto (YYYY-MM-DD o ISO string)
                const start = currentSelectedDate; 
                
                const end = null; // Asume que el modal no captura el final. Puedes ajustar esto.
                const description = null; // Asume que el modal no captura la descripción. Puedes ajustar esto.
                const allDay = currentSelectedIsAllDay; // El estado `allDay` de la selección

                console.log('Form submitted (Client - Propio). Event ID:', eventId, 'Title:', title, 'Start Date:', start, 'End Date:', end, 'Description:', description, 'All Day:', allDay);

                if (!title || !start) { 
                    alert('Por favor, ingresa el título del evento y asegúrate de haber seleccionado una fecha/hora.');
                    return;
                }
                
                let url, method;
                if (eventId) {
                    url = `/cliente/api/eventos/${eventId}`; 
                    method = 'PUT';
                } else {
                    url = '/cliente/api/eventos'; 
                    method = 'POST';
                }

                fetch(url, {
                    method: method,
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        title, 
                        start: start, 
                        end, 
                        description, 
                        allDay: allDay // <<-- Enviar el estado allDay al backend
                    }) 
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        console.log('Evento guardado exitosamente (Cliente - Propio):', data.message);
                        closeEventModal();
                        calendar.refetchEvents(); 
                        fetchAndRenderEventSidebar(); 
                    } else {
                        alert('Error al guardar evento (Cliente - Propio): ' + data.message);
                        console.error('Error al guardar evento (Cliente - Propio):', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error de red al guardar evento (Cliente - Propio):', error);
                    alert('Error de red al guardar evento.');
                });
            });

            // --- Manejo del Botón Eliminar en el Modal ---
            deleteEventBtn.addEventListener('click', function() {
                if (confirm('¿Estás seguro de que quieres eliminar este evento?')) {
                    const eventId = eventIdInput.value;
                    console.log('Attempting to delete event from sidebar (Client - Propio) with ID:', eventId);
                    fetch(`/cliente/api/eventos/${eventId}`, { method: 'DELETE' }) 
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('Evento eliminado desde sidebar (Client - Propio). Refetching events.');
                            closeEventModal();
                            calendar.refetchEvents(); 
                            fetchAndRenderEventSidebar(); 
                        } else {
                            alert('Error al eliminar: ' + data.message);
                            console.error('Error al eliminar (Client - Propio):', data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error de red al eliminar evento desde sidebar (Client - Propio):', error);
                        alert('Error de red al eliminar evento.');
                    });
                }
            });

            // --- Función para Renderizar Eventos en la Barra Lateral ---
            function renderEventSidebar(events) {
                console.log('--- Rendering sidebar events (Client - Propio) ---');
                console.log('Total events received for sidebar:', events.length);
                eventList.innerHTML = ''; 

                if (events && events.length > 0) {
                    const now = new Date(); 
                    const todayMidnightLocal = new Date(now.getFullYear(), now.getMonth(), now.getDate()); 

                    const filteredEvents = events.filter(event => {
                        const eventDateObj = new Date(event.start); 
                        
                        if (isNaN(eventDateObj.getTime())) {
                            console.warn('Fecha de evento inválida detectada para el sidebar (se ignorará):', event.start, 'Evento completo:', event);
                            return false; 
                        }

                        const eventMidnightLocal = new Date(eventDateObj.getFullYear(), eventDateObj.getMonth(), eventDateObj.getDate());
                        
                        const shouldInclude = eventMidnightLocal.getTime() >= todayMidnightLocal.getTime();

                        console.log(`Event "${event.title}" (Start: ${event.start}) - Parsed Date (for filter): ${eventMidnightLocal.toISOString()} - Is Today/Future: ${shouldInclude}`);
                        return shouldInclude;
                    }).sort((a, b) => new Date(a.start).getTime() - new Date(b.start).getTime()); 

                    console.log('Filtered events for sidebar (count):', filteredEvents.length);
                    console.log('Filtered events details (for sidebar):', filteredEvents.map(e => ({ id: e.id, title: e.title, start: e.start })));
                    console.log('--- End Debugging Sidebar Render (Client - Propio) ---');

                    if (filteredEvents.length > 0) {
                        filteredEvents.forEach(event => {
                            const li = document.createElement('li');
                            const eventDateForDisplay = new Date(event.start); 
                            
                            if (isNaN(eventDateForDisplay.getTime())) {
                                console.error('Error al renderizar: Fecha inválida detectada inesperadamente para el evento:', event);
                                return; 
                            }

                            const formattedDate = eventDateForDisplay.toLocaleDateString('es-VE', { year: 'numeric', month: 'long', day: 'numeric' });
                            
                            // Determinar si tiene componente de tiempo basándose en la propiedad `allDay`
                            const hasTimeComponent = event.allDay === 0; // Si allDay es 0, tiene componente de tiempo
                            const isMidnightTime = eventDateForDisplay.getHours() === 0 && eventDateForDisplay.getMinutes() === 0 && eventDateForDisplay.getSeconds() === 0 && eventDateForDisplay.getMilliseconds() === 0;

                            let formattedTime = '';
                            // Solo mostrar la hora si el evento no es de todo el día Y no es medianoche (que FullCalendar renderizaría como todo el día si no tiene tiempo)
                            if (hasTimeComponent && !isMidnightTime) { 
                                formattedTime = eventDateForDisplay.toLocaleTimeString('es-VE', { hour: '2-digit', minute: '2-digit', hour12: false }); 
                            }

                            li.innerHTML = `
                                <div>
                                    <strong>${event.title}</strong><br>
                                    <small>${formattedDate} ${formattedTime ? '- ' + formattedTime : ''}</small>
                                    ${event.description ? '<br><small>Descripción: ' + event.description + '</small>' : ''}
                                </div>
                                <div class="event-actions">
                                    <button class="edit-btn"
                                            data-id="${event.id}"
                                            data-title="${event.title}"
                                            data-start="${event.start}"
                                            data-end="${event.end || ''}"
                                            data-description="${event.description || ''}"
                                            data-all-day="${event.allDay}">Editar</button>
                                    <button class="delete-btn" data-id="${event.id}">Eliminar</button>
                                </div>
                            `;
                            eventList.appendChild(li);
                        });
                    } else {
                        eventList.innerHTML = '<li>No hay eventos próximos.</li>';
                        console.log('El filtro de fechas dejó el array de eventos próximos vacío (cliente - propio).');
                    }

                    eventList.querySelectorAll('.edit-btn').forEach(button => {
                        button.addEventListener('click', function() {
                            const eventId = this.dataset.id;
                            const eventTitle = this.dataset.title;
                            // Usamos el `data-start` directamente que ya fue formateado para el backend
                            currentSelectedDate = this.dataset.start;
                            // Convertimos el string a booleano/número para `currentSelectedIsAllDay`
                            currentSelectedIsAllDay = this.dataset.allDay === 'true' || this.dataset.allDay === '1'; 
                            openEventModal(eventId, eventTitle);
                        });
                    });

                    eventList.querySelectorAll('.delete-btn').forEach(button => {
                        button.addEventListener('click', function() {
                            if (confirm('¿Estás seguro de que quieres eliminar este evento?')) {
                                const eventId = this.dataset.id;
                                console.log('Attempting to delete event from sidebar (Client - Propio) with ID:', eventId);
                                fetch(`/cliente/api/eventos/${eventId}`, { method: 'DELETE' }) 
                                .then(response => response.json())
                                .then(data => {
                                    if (data.success) {
                                        console.log('Evento eliminado desde sidebar (Client - Propio). Refetching events.');
                                        closeEventModal();
                                        calendar.refetchEvents(); 
                                        fetchAndRenderEventSidebar(); 
                                    } else {
                                        alert('Error al eliminar: ' + data.message);
                                        console.error('Error al eliminar (Client - Propio):', data.message);
                                    }
                                })
                                .catch(error => {
                                    console.error('Error de red al eliminar evento desde sidebar (Client - Propio):', error);
                                    alert('Error de red al eliminar evento.');
                                });
                            }
                        });
                    });

                } else {
                    eventList.innerHTML = '<li>No hay eventos registrados.</li>'; 
                    console.log('La API no devolvió eventos o el array inicial para el sidebar está vacío (cliente - propio).');
                }
            }

            function fetchAndRenderEventSidebar() {
                console.log('Initiating fetch for sidebar events (Client - Propio)...');
                fetch('/cliente/api/eventos') 
                    .then(response => {
                        if (!response.ok) {
                            console.error('Fetch sidebar events API error response (Client - Propio):', response.status, response.statusText);
                            return response.json().then(err => {
                                throw new Error(`HTTP error! status: ${response.status} - ${err.message || response.statusText}`);
                            }).catch(() => {
                                throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                            });
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (Array.isArray(data)) {
                            renderEventSidebar(data);
                        } else {
                            console.error('La API de eventos no devolvió un array para el sidebar o es inesperada (Client - Propio):', data);
                        }
                    })
                    .catch(error => {
                        console.error('Error al cargar eventos para el sidebar (Client - Propio):', error);
                        alert('Error al cargar eventos para la barra lateral: ' + error.message);
                    });
            }

            fetchAndRenderEventSidebar(); 
        });
    </script>
</body>
</html>
